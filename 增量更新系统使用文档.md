# 增量更新系统使用文档

## 📋 系统概述

增量更新系统由两个核心模块组成：
- **UpdateBuilder**: 构建更新包，生成版本信息和增量更新文件
- **UpdateManager**: 管理更新流程，处理下载、验证和应用更新

## 🏗️ UpdateBuilder - 更新包构建器

### 功能特性
- ✅ 自动扫描应用文件并计算哈希值
- ✅ 支持大文件分块处理（50MB分块）
- ✅ 生成完整版本和增量更新信息
- ✅ 支持模型文件更新管理
- ✅ 忽略不必要的文件（缓存、日志等）

### 基本使用

#### 1. 命令行使用
```bash
# 构建完整更新包
python -m src.utils.UpdateBuilder ./app 1.2.0 --changelog "修复了重要bug"

# 构建增量更新包
python -m src.utils.UpdateBuilder ./app 1.2.0 --previous 1.1.0 --changelog "新增功能"

# 指定输出目录
python -m src.utils.UpdateBuilder ./app 1.2.0 --output ./releases
```

#### 2. Python API使用
```python
from src.utils.UpdateBuilder import UpdateBuilder

# 创建构建器
builder = UpdateBuilder("./app", "./releases")

# 生成更新信息
update_info = builder.generate_update_json(
    version="1.2.0",
    changelog="修复了重要bug",
    previous_version="1.1.0"
)

# 保存更新信息
json_path = builder.save_update_json(update_info)

# 创建完整更新包
current_json, incremental_json = builder.create_update_package(
    version="1.2.0",
    changelog="修复了重要bug",
    previous_version="1.1.0"
)
```

### 输出文件结构
```
releases/
├── update_1.2.0.json          # 完整版本信息
├── incremental_1.2.0.json     # 增量更新信息
├── models_1.2.0.json          # 模型更新信息
└── app_1.2.0/                 # 应用文件副本
    ├── main.py
    ├── src/
    └── ...
```

### 更新信息JSON格式

#### 完整版本信息 (update_1.2.0.json)
```json
{
  "version": "1.2.0",
  "previous_version": "1.1.0",
  "build_time": "2025-01-15T10:30:00",
  "changelog": "修复了重要bug",
  "total_files": 156,
  "total_size": 52428800,
  "files": [
    {
      "path": "main.py",
      "hash": "a1b2c3d4e5f6...",
      "size": 1024,
      "modified": "2025-01-15T10:25:00"
    },
    {
      "path": "models/large_model.gguf",
      "hash": "f6e5d4c3b2a1...",
      "size": 104857600,
      "chunks": ["chunk1_hash", "chunk2_hash"],
      "chunk_size": 52428800
    }
  ]
}
```

#### 增量更新信息 (incremental_1.2.0.json)
```json
{
  "version": "1.2.0",
  "previous_version": "1.1.0",
  "update_type": "incremental",
  "changed_files": [
    {
      "path": "main.py",
      "hash": "a1b2c3d4e5f6...",
      "size": 1024
    }
  ],
  "new_files": [
    {
      "path": "new_feature.py",
      "hash": "b2c3d4e5f6a1...",
      "size": 2048
    }
  ],
  "deleted_files": [
    {
      "path": "old_file.py"
    }
  ],
  "total_changes": 3,
  "total_size": 3072
}
```

## 🔄 UpdateManager - 更新管理器

### 功能特性
- ✅ 自动检查应用和模型更新
- ✅ 支持多镜像下载和断点续传
- ✅ 文件完整性验证
- ✅ 自动备份和恢复
- ✅ 配置化管理

### 基本使用

#### 1. 初始化配置
```python
from src.utils.UpdateManager import UpdateManager

# 创建更新管理器
update_manager = UpdateManager("my_update_config.json")

# 配置更新源
update_manager.update_config.update({
    "version_url": "https://your-cdn.com/version.json",
    "current_version": "1.1.0",
    "auto_download": False,
    "backup_before_update": True,
    "mirror_urls": [
        "https://mirror1.example.com/",
        "https://mirror2.example.com/"
    ]
})

# 保存配置
update_manager.save_config()
```

#### 2. 检查更新
```python
# 检查应用更新
app_update = update_manager.check_app_update()
if app_update and app_update.get("has_update"):
    print(f"发现新版本: {app_update['remote_version']}")
    print(f"更新日志: {app_update['changelog']}")

# 检查模型更新
model_updates = update_manager.check_model_update()
for model_name, update_info in model_updates.items():
    if update_info.get("has_update"):
        print(f"模型 {model_name} 有更新")
```

#### 3. 下载更新
```python
def progress_callback(url, progress, downloaded, total):
    print(f"下载进度: {progress:.1f}% ({downloaded//1024//1024}MB/{total//1024//1024}MB)")

def error_callback(error):
    print(f"下载失败: {error}")

# 下载应用更新
if app_update and app_update.get("has_update"):
    update_manager.download_app_update(
        app_update["update_url"],
        progress_callback=progress_callback,
        error_callback=error_callback
    )

# 下载模型更新
for model_name, update_info in model_updates.items():
    if update_info.get("has_update"):
        update_manager.download_model_update(
            model_name,
            update_info["url"],
            progress_callback=progress_callback,
            error_callback=error_callback
        )
```

### 配置文件格式 (update_config.json)
```json
{
  "version_url": "https://your-cdn.com/version.json",
  "app_name": "Aithon",
  "current_version": "1.1.0",
  "update_check_interval": 3600,
  "auto_download": false,
  "backup_before_update": true,
  "mirror_urls": [
    "https://mirror1.example.com/",
    "https://mirror2.example.com/"
  ]
}
```

## 🚀 完整部署流程

### 1. 开发者端 - 构建更新包

```bash
# 1. 准备应用目录
mkdir -p ./app_release
cp -r ./src ./app_release/
cp main.py ./app_release/

# 2. 构建更新包
python -m src.utils.UpdateBuilder ./app_release 1.2.0 \
    --changelog "新增AI模型管理功能" \
    --previous 1.1.0 \
    --output ./releases

# 3. 上传到CDN
# 将 releases/ 目录下的文件上传到你的CDN或OSS
```

### 2. 服务器端 - 配置更新源

```json
// version.json (放在CDN根目录)
{
  "app_version": "1.2.0",
  "app_update_url": "https://your-cdn.com/app_1.2.0.zip",
  "app_size": 52428800,
  "changelog": "新增AI模型管理功能",
  "models": {
    "qwen2.5-coder-1.5b-q5_k_m": {
      "version": "2025-01-15",
      "url": "https://your-cdn.com/models/qwen2.5-coder-1.5b-q5_k_m.gguf",
      "size": 1100000000,
      "description": "默认推荐模型"
    }
  }
}
```

### 3. 客户端 - 集成更新功能

```python
# 在应用启动时检查更新
from src.utils.UpdateManager import update_manager

def check_for_updates():
    """检查更新"""
    try:
        # 检查应用更新
        app_update = update_manager.check_app_update()
        if app_update and app_update.get("has_update"):
            show_update_dialog(app_update)
        
        # 检查模型更新
        model_updates = update_manager.check_model_update()
        if any(info.get("has_update") for info in model_updates.values()):
            show_model_update_dialog(model_updates)
            
    except Exception as e:
        print(f"检查更新失败: {e}")

def show_update_dialog(app_update):
    """显示更新对话框"""
    # 这里集成到你的UI中
    print(f"发现新版本 {app_update['remote_version']}")
    print(f"更新内容: {app_update['changelog']}")
    
    # 用户确认后开始下载
    if user_confirms_update():
        download_and_apply_update(app_update)

def download_and_apply_update(app_update):
    """下载并应用更新"""
    def progress_callback(url, progress, downloaded, total):
        update_progress_bar(progress)
    
    def error_callback(error):
        show_error_message(f"更新失败: {error}")
    
    # 创建备份
    if update_manager.update_config.get("backup_before_update"):
        update_manager.create_backup()
    
    # 下载更新
    update_manager.download_app_update(
        app_update["update_url"],
        progress_callback=progress_callback,
        error_callback=error_callback
    )
```

## 🛠️ 高级功能

### 1. 自定义忽略文件
```python
builder = UpdateBuilder("./app")
builder.ignore_patterns.update({
    "*.tmp",
    "debug_*",
    "test_*"
})
```

### 2. 大文件分块下载
```python
# 大文件会自动分块，支持断点续传
# 每个分块50MB，可以并行下载
```

### 3. 多镜像支持
```python
update_manager.update_config["mirror_urls"] = [
    "https://cdn1.example.com/",
    "https://cdn2.example.com/",
    "https://cdn3.example.com/"
]
```

### 4. 文件完整性验证
```python
# 下载完成后自动验证
is_valid = update_manager.verify_file_integrity(
    "downloaded_file.zip",
    "expected_hash_value"
)
```

## 📊 监控和日志

### 1. 更新状态监控
```python
# 获取更新状态
status = update_manager.get_update_status()
print(f"应用更新: {status['app_update']}")
print(f"模型更新: {status['model_updates']}")
print(f"最后检查: {status['last_check']}")
```

### 2. 本地版本信息
```python
# 获取本地版本信息
local_info = update_manager.get_local_version_info()
print(f"当前版本: {local_info['app_version']}")
print(f"已安装模型: {list(local_info['models'].keys())}")
```

## 🔧 故障排除

### 常见问题

1. **下载失败**
   - 检查网络连接
   - 尝试使用不同的镜像源
   - 检查CDN配置

2. **文件验证失败**
   - 重新下载文件
   - 检查文件是否完整
   - 验证哈希值是否正确

3. **更新应用失败**
   - 检查文件权限
   - 确保应用已关闭
   - 从备份恢复

### 调试模式
```python
import logging
logging.basicConfig(level=logging.DEBUG)

# 启用详细日志
update_manager.debug_mode = True
```

## 📈 性能优化

1. **并行下载**: 大文件分块可以并行下载
2. **断点续传**: 支持下载中断后继续
3. **增量更新**: 只下载变化的文件
4. **镜像加速**: 多镜像源提高下载速度
5. **本地缓存**: 避免重复下载相同文件

## 🔒 安全考虑

1. **文件验证**: 所有下载的文件都会验证哈希值
2. **HTTPS**: 建议使用HTTPS传输
3. **备份机制**: 更新前自动创建备份
4. **权限控制**: 限制更新文件的访问权限

---

这个增量更新系统提供了完整的应用和模型更新解决方案，支持国内网络环境，具有良好的容错性和用户体验。
